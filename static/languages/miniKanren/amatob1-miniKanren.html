<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
            <title>Introduction to miniKanmren</title>
            <link rel="stylesheet" type="text/css" href="pl.css"/>
        </head>
        <body>
            <header>
	Introduction to the miniKanren family of  Languages
            </header>
            <article>
                <div class="subheader">Key Language Concepts in miniKanren</div>
<table>
	<tbody>
	<tr>
		<td>First-Class Functions</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>λ Expressions</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Higher-Order Functions</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>First-Class Closures</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Currying</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Continuation-Passing Style</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>First-Class Continuations</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Pattern Matching</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="indeterminate"></label></td>
	</tr>
	<tr>
		<td>Strong Typing</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Type Systems</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Lazy Evaluation</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>List/Generator Comprehension</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Message Passing</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Actor Model of Concurrency</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Coroutines</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Channels</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Communicating Sequential Processes</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Homoiconic</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="checked"></label></td>
	</tr>
	<tr>
		<td>Concurrency</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Callbacks</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Type Inference</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Dynamic Dispatch</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="unchecked"></label></td>
	</tr>
	<tr>
		<td>Dynamic Typing</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="checked"></label></td>
	</tr>
	<tr>
		<td>Heterogeneous Lists</td>
		<td><label><input type="checkbox" onclick="checkboxOnClick(this);" class="checked"></label></td>
	</tr>
	</tbody>
	
	<script>
		let checks = document.getElementsByClassName("checked");
		let lines = document.getElementsByClassName("indeterminate");
		
		for (let i = 0; i < checks.length; i++) checks[i].checked = true;
		
		for (let i = 0; i < lines.length; i++) lines[i].indeterminate = true;
		
		function checkboxOnClick(self) {
			switch (self.classList[0]) {
				case "checked":
					self.checked = true;
					break;
				case "indeterminate":
					self.indeterminate = true;
					break;
				default:
					self.checked = false;
			}
		}
	</script>
</table>

            <div class="subheader">Core miniKanren</div>
                            <li>Family of languages</li>
                <ul>
                    <li>Core operators same between implementations</li>
                    <li>Varients have additional operators to make miniKanren more powerful or simpler to develop</li>
                    <li>Support for miniKanren availble inside 40+ languages through libraries [ORG]</li>
                    <li>Original implemenation is in Scheme</li>

                </ul>
                <li>Relational / Logic Language</li>
                <ul>
                    <li>Based on predicate logic</li>
                    <li>Core langauge has analogies for <tt>AND, OR,</tt> and Equivalence</li>
                    <li>Commen extensions support <tt>NOT</tt>
                    </li>
                </ul>
                <li>Pure Declarative Syntax</li>
                <li>Syntax structure (usually) resembles Lisp</li>
                <li>Typeless</li>
                <li>Not functional, but many programs rely heavily on recursion</li>
                <li>Primarily developed by Daniel P. Friedman and William E. Bryd [RPM]</li>

                <li>Expessions are evaluated using the <code>run</code> command</li>
                <li>All statements in an exprssion are evaualted simutaneously</li>
                <li>Interpreter evaluates expression to find all possible values a variable can be</li>
                <li>Output is a list containing valid values</li>
                <li>Three core operators: <code>==, fresh, conde</code>
                </li>
                <ul>
                    <li>
                        <code>==</code> unifies two values, ensuring they are the same</li>
                    <li>
                        <code>fresh</code> introduces new varaibles</li>
                    <li>
                        <code>conde</code> allows for multiple different possiblities</li>
                </ul>
                <li>Varients add additional operators which specify the values a varibale cannot be</li>
                <li>Expressions are written in prefix notation</li>
                <li>Lists are heterogeneous</li>
                <li>Most functions in host langauge will not operate on miniKanren varaibles</li>
                <li>All examples shown here are valid in <a href="https://github.com/miniKanren/Racket-miniKanren">Racket-miniKanren</a>
  availble with <a href="https://github.com/miniKanren/Racket-miniKanren/wiki/How-to-Install-as-a-Package-from-Dr.-Racket"> Dr. Racket Package Installer</a>
                </li>
            </ul>

            <div class="subheader">Unification</div>
            <ul>
                <li>Accomplished through <code>==</code> operator</li>
                <li>Unifies two values together
                    <ul>
                        <li>Values must be equivalent for the whole run</li>
                        <li>Can unify variable to number, symbol, or list</li>
                        <li>Unification is fully communative: the order of the values after <code>==</code> does not matter</li>
                    </ul>
                </li>

                <code class="code-block">
        (run 1 (q) (== q 2))<br/>
        &gt;&gt; '(2)<br/>
        (run 1 (q) (== 'foo q))<br/>
        &gt;&gt; '('foo)<br/>
        (run 1 (q) (== q '(1 2 3)))<br/>
        &gt;&gt; '('(1 2 3))<br/>
                </code>
                <li>Output is the empty list if the unification is impossible</li>
                <code class="code-block">
        (run 1 (q) (== q 1)(== q 2))<br/>
        &gt;&gt; '()<br/>
        (run 1 (q) (== 1 2))<br/>
        &gt;&gt; '()<br/>
        (run 1 (q) (== q `(,1 . ,q)))<br/>
        &gt;&gt; '()<br/>
                </code>
                <li>Output is <code>'(_.0)</code> if the answer can be any value</li>
                <code class="code-block">
        (run 1 (q) (== 1 1))<br/>
        &gt;&gt; '(_.0)<br/>
                </code>
            </ul> 
            <div class="subheader">fresh</div>
            <ul>
                <li>Introduces new varabiles</li>
                <li>These new variables can be unified with other variables, numbers, symbols, and lists</li>
                <code class="code-block">
(run 1 (q) (fresh (x y)<br/>
&#8195(== x 2)<br/>
&#8195(== y x)<br/>
&#8195(== q x)))<br/>
&gt;&gt; '(2)<br/>
(run 1 (q) (fresh (a d)<br/>
&#8195(== 1 a)<br/>
&#8195(== '('foo 'bar) d)<br/>
&#8195(== q `(,a . ,d))))<br/>
&gt;&gt; '(1 'foo 'bar)
                </code>
                <li>By convention, lists which contain a variable are unified explicity with the backtick (<tt>`</tt>) rather than with a cons</li>
                <code class="code-block">
        THIS: (== q `(,a . ,d))<br/>
        NOT:  (== q (cons a d))
                </code>
            </ul> 
            <div class="subheader">conde</div>
            <ul>
                <li>Allows one of multiple options to occur</li>
                <li>Syntax similar to <code>cond</code> in Lisp</li>
                <li>All options are tested and any/all can return</li>
                <li>Operates simularly to an <tt>OR</tt> in predicate logic</li>
                <code class="code-block">
        (run 2 (q) (conde <br/>
&#8195((== q 1))<br/>
&#8195((== q 2))))<br/>
        &gt;&gt; '(1 2)<br/>
                </code>
            </pre>
            <li>
                <code>conde</code> can be  used to create recursion</li>
            <li>Functions in miniKanren get their structure from the host language, in this case Racket</li>
            <li>By convention, miniKanren functions end in <code>o</code> to differentiate them from their host language</li>
            <code class="code-block">
        (define loopo<br/>
         &#8195lambda (q)<br/>
         &#8195(conde<br/>
         &#8195&#8195((== q 1))<br/>
         &#8195&#8195((== q 2))<br/>
         &#8195&#8195((loopo q)))))<br/>
        (run 5 (q) (loopo q))<br/>
        &gt;&gt; '(1 2 1 2 1)
            </code>
            <li>While most implentations test the conde clauses from top to bottom, there is offically no specification for the order the clauses are tested. It is possbile the results of
  a run will be different between different runs, implementations, or host langauges.
                <ul>
                    <li>Generally it is best to place recursive calls last in a series of clauses, since the last line will usually be the last to run</li>
                </ul>
            </li>
        </ul>
        <div class="subheader">run</div>
        <ul>
            <li>Used to execute miniKanren code</li>
            <li>Syntax: run (num of runs) ((variable)) (code)</li>
            <li>With <code>conde</code> multiple, possibly infinite, results possible. <code>run</code> allows the programmer to specify a maximum number of results to obtain</li>
            <ul>
                <li>If there are fewer results than the number of possible, the code will return with all possible results</li>
            </ul>
            <li>
                <code>run*</code> runs until all possible results are found</li>
            <ul>
                <li>It is easy to get into a infinite loop, so watch out for this opetion</li>
            </ul>
            <code class="code-block">
        (run 1 (q) (loopo q))<br/>
        &gt;&gt; '(1)<br/>
        (run 5 (q) (loopo q))<br/>
        &gt;&gt; '(1 2 1 2 1)<br/>
        (run* (q) (loopo q))<br/>
        Causes infinite recursion and never returns<br/>
            </code>
        </ul>
        <div class="subheader">run</div>
        <ul>
            <li>Racket-miniKanren also includes some additional, non-core, operators: <code>=/=, numbero, symbolo</code>
            </li>
            <li>
                <code>=/=</code>: the variable is never a certain value</li>
            <code class="code-block">
        (run 1 (q) (=/= q 5)<br/>
        &gt;&gt; '((_.0 (=/= ((_.0 . 5)))))<br/>
            </code>
            <ul>
                <li>q can be any value except 5</li>
            </ul>
            <code class="code-block">
        (run 1 (q) (fresh (p r)<br/>
        &#8195&#8195(=/= '(1 2) `(,p ,r))<br/>
        &#8195&#8195(== `(,p ,r) q)))<br/>
        &gt;&gt; '(((_.0 _.1) (=/= ((_.0 . 1) (_.1 . 2)))))<br/>
            </code>
            <ul>
                <li>q can be a list of any two values except the second value cannot be 2 if the first is 1 and the first cannot be 1 when the second is 2</li>
            </ul>
            <li>
                <code>numbero</code>: the variable must be a number, not a symbol or list</li>
            <code class="code-block">
        (run 1 (q) (numbero q))<br/>
        &gt;&gt; '((_.0 (num _.0)))<br/>
        (run 1 (q) (numbero q)(== q 'foo))<br/>
        &gt;&gt; '()<br/>
            </code>
            <li>
                <code>symbolo</code>: the variable must be a symbol (like 'foo), not a number or list</li>
            <code class="code-block">
        (run 1 (q) (symbolo q))<br/>
        &gt;&gt; '((_.0 (sym _.0)))<br/>
        (run 1 (q) (symbolo q)(== q 1))<br/>
        &gt;&gt; '()<br/>
            </code>
        </ul>
        <div class="subheader">rembero example</div>
        <ul>
            <li>An example showing the conversion of a Racket function to miniKanren demonstrates how wo use the operators</li>
            <li>Rember takes a element and a list and removes the first instance of the element from the list</li>
            <code class="code-block">
        (define rember<br/>
        &#8195(lambda (x l)<br/>
        &#8195&#8195(cond<br/>
        &#8195&#8195&#8195((null? l) '())<br/>
        &#8195&#8195&#8195((eqv? (car l) x) (cdr l))<br/>
        &#8195&#8195&#8195(else (cons (car l) (rember x (cdr l)))))))<br/>
        (rember 3 '(1 2 3 4))<br/>
        &gt;&gt; '(1 2 4)<br/>
            </code>
            <li>This is rembero in miniKanren</li>
            <code class="code-block">
        (define rembero<br/>
         &#8195(lambda (x l out)<br/>
        &#8195&#8195(conde<br/>
        &#8195&#8195&#8195((== '() l)(== '() out))<br/>
        &#8195&#8195&#8195((fresh (d)<br/>
        &#8195&#8195&#8195(== `(,x . ,d) l)<br/>
        &#8195&#8195&#8195&#8195(== d out)))<br/>
        &#8195&#8195&#8195&#8195((fresh (a d res)<br/>
        &#8195&#8195&#8195&#8195&#8195(== `(,a . ,d) l)<br/>
        &#8195&#8195&#8195&#8195&#8195(=/= a x)<br/>
        &#8195&#8195&#8195&#8195&#8195(== `(,a . ,res) out)<br/>
        &#8195&#8195&#8195&#8195&#8195(rembero x d res))))))<br/>
            </code>
            <ul>
                <li>Rembero must take an additional element <code>out</code> since miniKanren functions must store their output in a variable</li>

                <code class="code-block">
        ((== '() l)(== '() out))
                </code>
                <li>Checks if the end of the list is reached, and unifies <code>out</code> with <code>'()</code> if it is</li>
                <code class="code-block">
        ((fresh (d)<br/>
        &#8195(== `(,x . ,d) l)<br/>
        &#8195(== d out)))<br/>
                </code>
                <li>Intoduces a new variable <tt>d</tt> then unifies it to the <code>cdr</code> of the list if <tt>x</tt> is equal to the <code>car</code> of the list. <tt>d</tt> is unified to out</li>
                <ul>
                    <li>This clause could have been written <code>(== `(,x . ,out) l)</code> but this is less clear on what is being done</li>
                </ul>
                <code class="code-block">
        ((fresh (a d res)<br/>
        &#8195(== `(,a . ,d) l)<br/>
        &#8195(=/= a x)<br/>
        &#8195(== `(,a . ,res) out)<br/>
        &#8195(rembero x d res))))))))<br/>
                </code>
                <li>Three new varialbes are introduced</li>
                <li>
                    <code>(== `(,a . ,d) l)</code> unifies <tt>a</tt> and <tt>d</tt> to the <code>car</code> and <code>cdr</code> of the list</li>
                <li>
                    <code>(=/= a x)</code> ensures that the <code>car</code> of the list is not <tt>x</tt>
                </li>
                <ul>
                    <li>Since all conde clauses run simultaneously, the third clause could run on the same list as the second. This disequality prevents both from running on the same list</li>
                </ul>
                <li>
                    <code>(== `(,a . ,res) out)</code> creates a list from <tt>a</tt> and the result of the fifth line and unifies it to out</li>
                <li>
                    <code>(rembero x d res))))))</code> calls <code>rembero</code> recursively on the <code>cdr</code> of the list, storing its output in <tt>res</tt>
                </li>
            </ul>
            <li>
                <code>rembero</code> operates the same as <code>rember</code> if the unknown variable is the placed at the output</li>
            <code class="code-block">
        (run* (q) (rembero 3 '(1 2 3 4) q))<br/>
        &gt;&gt; '((1 2 4))<br/>
            </code>

            <li>miniKanren alows you two run the function 'backwards' getting the input that results in a particular output</li>
            <code class="code-block">
       (run* (q) (rembero q '(1 2 3 4) '(1 2 3)))<br/>
        &gt;&gt; '(4)<br/>
        (run* (q) (rembero 2 q '(1 3)))<br/>
        &gt;&gt; '((2 1 3) (1 2 3) (1 3) (1 3 2))<br/>
        (run* (q) (fresh (x l)<br/>
        &#8195(rembero x l '(1 2))<br/>
        &#8195&#8195(== `(x, . (,l)) q)))<br/>
        &#8195&#8195(== `(x, . (,l)) q)))<br/>
        &gt;&gt; '((_.0 (_.0 1 2)) ((_.0 (1 _.0 2)) (=/= ((_.0 . 1)))) ((_.0 (1 2)) (=/= ((_.0 . 1)) ((_.0 . 2)))) ((_.0 (1 2 _.0)) (=/= ((_.0 . 1)) ((_.0 . 2)))))
            </code>


            <li>This third result can be hard to understand, so here it is broken down</li>
            <ul>
                <li>
                    <code>(_.0 (_.0 1 2))</code>: x can be anything if it is the first number in the list</li>
            </ul>
            <ul>
                <li>
                    <code>((_.0 (1 _.0 2)) (=/= ((_.0 . 1))))</code>: x can be anything except 1 if it is the second element in the list</li>
            </ul>
            <ul>
                <li>
                    <code>((_.0 (1 2)) (=/= ((_.0 . 1)) ((_.0 . 2))))</code>: x can be anything except 1 or 2 if it is not in the list</li>
            </ul>
            <ul>
                <li>
                    <code>((_.0 (1 2 _.0)) (=/= ((_.0 . 1)) ((_.0 . 2))))</code>: x can be any number except 1 or 2 if it is the third element in the list</li>
            </ul>
        </ul>
        <div class="subheader">Exercises</div>
The following are programming exercises that incorporate essential miniKanren concepts:
        <ul>
            <li>Many extensions to miniKanren include the <code>absento</code> operator. This operator accepts two inputs: an element and a list. If the element is in the list
then then <code>absento</code> fails. If the elements in not in the list, <code>absento</code> succeeds. Implement <code>absento</code> in Racket-miniKanren.</li>

Examples:
            <code class="code-block">
        (run 1 (q) (absento 7 '(1 2 3)))<br/>
        >> '(_.0)<br/>
        (run 1 (q) (absento 2 '(1 2 3)))<br/>
        >> '()<br/>
        (run 1 (q) (absento q '(1 2 3))(== q 5))<br/>
        >> '(5)<br/>
        (run 1 (q) (absento q '(1 2 3))(== q 3))<br/>
        >> '()<br/>
        (run 1 (q) (absento q '('foo 'bar)))<br/>
        >> '((_.0 (=/= ((_.0 quote bar)) ((_.0 quote foo)))))<br/>
        (run 4 (q) (absento 3 q))<br/>
       >> '(() ((_.0) (=/= ((_.0 . 3)))) ((_.0 _.1) (=/= ((_.0 . 3)) ((_.1 . 3)))) ((_.0 _.1 _.2) (=/= ((_.0 . 3)) ((_.1 . 3)) ((_.2 . 3)))))
            </code>

            <li>Relational languages like miniKanren can be used for describing first order predicate logic. Define a miniKanren function which encodes the binary expression 
                <code>(x&#8743y&#8743z)&#8744(&#172x&#8743&#172y)&#8744(&#172x&#8743&#172z)</code> where <code>&#8743</code> is <tt>AND</tt>, <code>&#8744</code> is <tt>OR</tt>, and <code>&#172</code> is <tt>NOT</tt>. 
The function should accept 3 variables, x, y, z, and should fail if given an invalid input and should succeed if given a valid input.
            </li>
            Examples:
            <code class="code-block">
        (run 1 (q) (binExp 1 1 1))<br/>
        >> '(_.0)<br/>
        (run 1 (q) (binExp 1 0 0))<br/>
        >> '()<br/>
        (run 1 (q) (binExp q 0 0))
        >> '(0)
            </code>
        </ul>
        <div class="subheader">References</div>
        <ul>
            <table>
                <tbody>
                    <tr>
                        <td valign="top">[ORG]</td>
                        <td>
                            <i>miniKanren</i>.
                            <a href="http://minikanren.org/">miniKanren.org</a>, 2019</td>
                    </tr>
                    <tr>
                        <td valign="top">[RPM]</td>
                        <td>W. Byrd, <i>Relational Programming In miniKanren: Techniques, Applications, and Implementations</i>. Indiana University, 2009</td>
                    </tr>
                </tbody>
            </table>
        </ul>
    </article>

    <script src="pl.js"></script>
    <hr noshade size=“2” width=“75%”>

<font size=“1” face=“Verdana, Helvetica, sans-serif, Times”>
&copy; B. Amato, Fall 2019, University of Dayton.
Permission to use ideas about
the organization of topics and any notes or material is granted,
provided suitable acknowledgments and citations are made.
</font>
</body>
</html>