import kotlin.random.Random

val size = 11
val EMPTY_BOARD =  State(size)

var count = 0
var solutions = arrayListOf(arrayOf(arrayOf<Int>()))


fun main(args: Array<String>) {
    var starting =  State(size)
    if(args.contains("b1")){
        dumbBrute(starting, 0)
    }else if(args.contains("b2")){
        smartBrute(starting, 0, arrayListOf<Int>())
    }else if(args.contains("f")) {
        forwardCheck(starting, 0)
    }else
        arcs(starting, 0)

    println("The number of solutions for n = " + size +" is: " + count)
    //return random solution
    if(count > 0){
        val result  = solutions[Random.nextInt(1, count)]
        for(col in result){
            for(row in col){
                print("$row ")
            }
            println()
        }
    }
}

fun arcs(state: State, curCol: Int) {
    var next = State(size)

    //Place the Queen in the column
    for (move in state.validmoves[curCol]) {
        next.clone(state)
        next.numqueens++
        next.locations.add(Pair(curCol, move))
        next.board[move][curCol] = 1

        if (next.numqueens == size) { //Valid solution found
            count++
            save(next)
            return
        }

        next.validmoves[curCol].clear()
        var i = 1;
        for (col in (curCol + 1)..(size - 1)) { //update other cols
            next.validmoves[col].remove(move) //update same row
            next.validmoves[col].remove(move + i) //down right diag
            next.validmoves[col].remove(move - i++) //up right diag
        }

        if(curCol >= size - 1)
            return  //No implications to check
        implications(next, curCol)
        arcs(next, curCol+1)
    }
}

fun forwardCheck(state: State, curCol: Int) {
    var next = State(size)

    if (state.numqueens == size) {
        count++ //No validation needed
        save(state)
        return
    }

    for (move in state.validmoves[curCol]) {
        next.clone(state)
        next.numqueens++
        next.locations.add(Pair(curCol, move))
        next.board[move][curCol] = 1

        var i = 1;
        for (col in (curCol + 1)..(size - 1)) {    //update other cols
            next.validmoves[col].remove(move) //update same row
            next.validmoves[col].remove(move + i) //down right diag
            next.validmoves[col].remove(move - i++) //up right diag
        }
        forwardCheck(next, curCol + 1)
    }
    return
}

fun smartBrute(state: State, next: Int, takenCol: ArrayList<Int>) {
    //Done placing queens?
    if (state.numqueens == size) { //All queens placed
        if (state.valid()) {
            count++
            save(state)
            return
        } else
            return
    }

    //Place a queen and recurse
    for (col in 0..(size - 1)) {
        if (takenCol.contains(col)) {
            continue
        }

        var newState = State(size)
        newState.clone(state)
        newState.board[next][col] = 1
        newState.numqueens++
        newState.locations.add(Pair(next, col))
        takenCol.add(col)

        smartBrute(newState, next + 1, takenCol)
        takenCol.remove(col)
    }
    return
}

fun dumbBrute(state: State, next: Int) {
    //Done placing queens?
    if (state.numqueens == size) { //All queens placed
        if (state.valid()) {
            count++
            save(state)
            return
        } else
            return
    }

    for (col in 0..(size - 1)) {
        var newState = State(size)
        newState.clone(state)
        newState.board[next][col] = 1
        newState.numqueens++
        newState.locations.add(Pair(next, col))

        dumbBrute(newState, next + 1)
    }
    return
}

fun copyValid(state: State): ArrayList<ArrayList<Int>> {
    var copy = arrayListOf(arrayListOf<Int>())
    copy.removeAt(0)
    var i = 0
    for (col in state.validmoves) {
        copy.add(arrayListOf<Int>())
        for (entry in col) {
            copy[i].add(entry)
        }
        i++
    }
    return copy
}

fun implications(next: State, curCol: Int){
    var i = 0


    var implications = arrayListOf(arrayListOf(arrayListOf<Int>()))
    implications.removeAt(0)

    for (validmove in next.validmoves[curCol+1]) //copy board state
        implications.add(copyValid(next))

    //create boards for prospective move
    var j = 0
    for(validmove in next.validmoves[curCol+1]){
        i = 1

        implications[j][curCol+1].clear()
        for(col in (curCol+2)..(size-1)) {
            implications[j][col].remove(validmove) //update same row
            implications[j][col].remove(validmove + i) //down right diag
            implications[j][col].remove(validmove - i++) //up right diag
        }
        j++
    }

    //Generate aggregate
    var newboard = arrayListOf(arrayListOf<Int>())
    for(col in 0..(size-2)){
        newboard.add(arrayListOf<Int>())
    }

    for(board in implications){ //Build the aggregate board
        var i = 0;
        for(col in board){
            for(move in col){
                if(!newboard[i].contains(move)) //Dont add duplicates
                    newboard[i].add(move)
            }
            i++
        }

    }
    for(validmove in next.validmoves[curCol+1]){ //Add in the next col to be checked
        newboard[curCol+1].add(validmove)
    }

    //Check for changes in the board
    i = 0
    var diff = false
    for(col in next.validmoves){
        for(row in col) {
            if (!newboard[i].contains(row))
                diff = true
        }
        i++
    }
    next.validmoves = newboard
    if(diff) //check for more implications if the board has changed
        implications(next, curCol)

}

fun save(state: State){
    solutions.add(state.board)
}
