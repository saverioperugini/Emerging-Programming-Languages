<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Introduction to the Idris Programming Language</title>
	<link rel="stylesheet" type="text/css" href="pl.css"/>
</head>
<body>
<header>
	Introduction to the Idris Programming Language
</header>
<article>
	<div class="subheader">Key Language Concepts in Idris</div>
	
	<ul>
		<li>created by Edwin Brady, professor at University of St. Andrews in Scotland</li>
		<li>designed to be a general purpose, "pacman complete" functional programming language with dependent types</li>
		<li>tries to break the current way types are thought of </li>
			<ul>
				<li>types are thought of as a kind of way to help make sure a program works.</li>
				<li>safety is important, but types can do so much more. We can use types to help us get to the right program.</li>
				<li>end goal of such a strongly-typed system is to have the programmer interact with the machine to help you write your programs!!</li>
			</ul>
		<li>encourages "Type driven development": write the program with types, then implement</li>
		
		
		
		
		<li>based off of Haskell and uses Haskell's Prelude, but uses eager evaluation and ML-esque syntax.</li>
		<li>even more strongly typed than ML and Haskell, where you can declare  with eager evaluation. </li>
		<li>unlike Haskell and ML, Idris is a dependently typed language. </li>
		<li>with dependent types, the language must have a first-class type system.</li>
		<li>this is because dependent types can return a different type as output for different inputs (of potentially different types).</li>

	</ul>
	
	<div class="subheader">Core Idris</div>
	<ul>
		<li>simple expressions, many aspects based on Haskell and Prelude</li>
		<li>homogenous lists</li>
		<li>heterogenous tuples</li>
		<li>list operators: <code>::</code> (cons), <code>++</code> (append) </li>
		<li>higher order functions</li>
		<li>first-class types, functions, and values</li>
		<li>powerful type system</li>
		<li>allows development through interaction with the language</li>
		<li>formal proof assistant to formally prove aspects of the program</li>
		<li>types can be dependent on values</li>
		<li>type-driven development</li>
	</ul>
	<div class="subheader">Essentials</div>
	<ul>
		<li>boolean operators: <code>||</code>, <code>&&</code>, <code>not</code></li>
		<li>convert operator to infix: <code>(+)</code>, <code>(*)</code>, <code>(::)</code></li>
		<li>basic arithmetic: <code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>, <code>mod</code>,<code>div</code></li>
		<li>if-then-else expressions</li>
		<li>comments:</li>
			<ul>
				<li>single line: <code>-- a single line comment</code>
				<li>multi-line: <code class="code-block">
							|{- <br>
							|a <br>
							|multi-line <br>
							|comment <br>
							|-} 
							</code>
				</li>
			</ul>
		<li>many Haskell functions are available in Idris due to Idris implementing Prelude</li>
			<ul>
				<li> e.g. <code>map</code>, <code>foldl</code>, <code>foldr</code>, etc. </li>
				<li> haskell properties like currying and uncurrying are also available as a result </li>
			</ul>
		<li><code>data</code> keyword to define a type</li>
		<li><code>where</code> keyword to define local data in a function</li>
		<li><code>using</code> keyword to explicitly define implicit arguments</li>
		<li><code>myfunction : a -> a</code> Definining a function that takes an argument of type <code>a</code> and returns a value of the same type</li>
		<li> some core Idris interactive commands: </li>
			<ul>
				<li> ctrl-alt-a : add skeleton definition </li>
				<li> ctrl-alt-t : inspect type </li>
				<li> ctrl-alt-d : inspect definition </li>
				<li> ctrl-alt-c : case-split </li>
				<li> ctrl-alt-l : lifts a hole into a top-level function that you can add your own definition for </li>
				<li>ctrl-alt-s : search for proof of a hole </li>
			</ul>

	</ul>
	<div class="subheader">Lists</div>
	<ul>
		<li>Offers pattern matching, like Haskell</li>
		<li><code>(x::xs)</code> for seperating a list into car and cdr</li>
		<li><code>_</code> for anything</li>
		<li><code>[]</code> or <code>Nil</code> for empty list</li>
		<li><code>List a</code> to define a list of type <code>a</code></li>
		
	</ul>
	<div class="subheader">Some Functions</div>
	<ul>
		<li> Simple add function using the built-in Nat type. </li>
			<ul>
				<li> Z stands for Zero, (S k) means that k is some natural that has a successor. </li>
				<code class="code-block">
				|add : Nat -> Nat -> Nat <br>
				|add Z x = x<br>
				|add (S k) x = S (add k x)<br>
				</code>
			</ul>
		<li>Simple multiply function using the same Nat type. </li>
			<ul>
				<code class="code-block">
				|mul : Nat -> Nat -> Nat<br>
				|mul Z y = Z<br>
				|mul (S k) y = add y (mul k y)<br>
				</code>
			</ul>
		
		<li>Fibonnaci sequence with Nats</li>
			<ul>
				<code class="code-block">
				|fibo : Nat -> Nat<br>
				|fibo Z = 1<br>
				|fibo (S Z) = 1<br>
				|fibo (S (S n)) = fibo (S n) + fibo (n)<br>
				</code>
			</ul>
	
	</ul>
	
	<div class="subheader">Idris Development</div>
	<ul>
		<li>one of the defining features of Idris is its ability to help you figure out a programming problem through the ability to define very strong types.</li>
		<li>First, let us define the <code>vector</code> data type<br/>
			<code class="code-block">
				|data Vect : Nat -> Type -> Type where<br>
				|<t>Nil : Vect Z a<br>
				|	(::) : a -> Vect k a -> Vect (S k) a<br>
			</code>
		</li>
		<li>notice the <code>(::)</code> cons operator, which has the ability to return a <code>Vect</code> of <code>(S k)</code> length</li>
		
		<li>Now, lets define the append function<br/>
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
			</code>
		</li>
		
		<li>Notice the lengths in the Vectors are built-into the types. This allows Idris to help us create the function. Now, add a clause using CTRL-ALT-A<br/>
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
				|append xs ys = ?append_rhs<br>
			</code>
		</li>
		
		<li>?append_rhs is a hole in the program. Holes are syntactically valid, and let the program be type-checked successfully without fully implementing the program. </li>
		<li>Now, if we case-split on <code>xs</code> using CTRL-ALT-C,<br/>
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
				|append [] ys = ?append_rhs_1<br>
				|append (x :: xs) ys = ?append_rhs_2<br>
			</code>
		<br>Another hole spawns and <code>xs</code> is split into the only two options.</li>
		
		<li>Now, we have enough inforation to fill the hole in the first clause with the Nil <code>xs</code> list. If you use CTRL-ALT-S on ?append_rhs_1, you can fill the hole with what Idris deduces,<br/>
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
				|append [] ys = ys<br>
				|append (x :: xs) ys = ?append_rhs_2<br>
			</code>
		<br>Which is exactly what we want.<br></li>
		
		<li>Now, if we case-split on <code>ys</code>,<br/>
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
				|append [] ys = ys<br>
				|append (x :: xs) [] = ?append_rhs_2<br>
				|append (x :: xs) (y :: ys) = ?append_rhs_3<br>
			</code>
			<br>and then search for a proof for both holes:
			<code class="code-block">
				|append : Vect n a -> Vect m a -> Vect (n+m) a<br>
				|append [] ys = ys<br>
				|append (x :: xs) [] = append xs []<br>
				|append (x :: xs) (y :: ys) = x :: append xs (y :: ys)<br>
			</code>
			<br>Which is exactly what we want.<br>
		</li>
		
		<li>More complex functions can be figured out in this way, and Idris proves to be extremely useful for figuring out programs just from their type!</li>
	
	</ul>
	
	<div class="subheader">Formal Proving</div>
	<ul>
		<li>Formal proving in Idris works in a very similar way, as it uses the same hotkeys and assistants for finding proofs as it does finding definitions from holes.</li>
		<li>To define a function to prove the associativity of addition given three arguments:<br> <code>plusAssoc : (a, b, c : Nat) -> a `plus` (b `plus` c) = (a `plus` b) `plus` c </code></li>
		<li>Notice the <code>=</code>, which signals to the intepreter that this is a proof that needs to be solved.</li>
		
		<li>You can use the same strategy to figure out these predicates using Idris to solve predicates and holes.</li>
		
		<li>Adding a clause to the declaration:<br/>
			<code class="code-block">
				|plusAssoc : (a, b, c : Nat) -> a `plus` (b `plus` c) = (a `plus` b) `plus` c <br>
				|plusAssoc a b c = ?plusAssoc_rhs<br>
			</code>
			<br>Notice the hole. Using CTRL-ALT-T to type-check the hole, you can see what you need to prove.<br>
			<code class="code-block">
			|a : Nat<br>
			|b : Nat<br>
			|c : Nat<br>
			|--------------------------------------<br>
			|plusAssoc_rhs : plus a (plus b c) = plus (plus a b) c<br>
			</code>
			<br>The goal is at the bottom.<br>			
		</li>
		
		<li>Similar to before, you can case-split on the arguments to spawn more holes and try to figure out more of the program. Case-splitting on <code>a</code></br>
			<code class="code-block">
				|plusAssoc : (a, b, c : Nat) -> a `plus` (b `plus` c) = (a `plus` b) `plus` c<br>
				|plusAssoc Z b c = ?plusAssoc_rhs_1<br>
				|plusAssoc (S k) b c = ?plusAssoc_rhs_2<br>
			</code>
			<br>The first hole is trivial to solve, as if you typecheck, the predicate on both sides are the same. Thus, searching for a proof results in:<br>
			<code class="code-block">
				|plusAssoc : (a, b, c : Nat) -> a `plus` (b `plus` c) = (a `plus` b) `plus` c<br>
				|plusAssoc Z b c = Refl<br>
				|plusAssoc (S k) b c = ?plusAssoc_rhs_2<br>
			</code>
			<br>Refl stands for Reflexive, which means both sides of the predicate are the same. Type checking the second hole, however, is less trivial to solve:</br>
			<code class="code-block">
				|k : Nat<br>
				|b : Nat<br>
				|c : Nat<br>
				|--------------------------------------<br>
				|plusAssoc_rhs_2 : S (plus k (plus b c)) = S (plus (plus k b) c)<br>
			</code>
			<br>There is a keyword useful for proving theorems: <code>rewrite</code>. <br>Rewrite lets you take an expression and rewrite it into an equivalent expression. If we rewrite the second half of the equation as: </br>
			<code class="code-block">
				|plusAssoc (S k) b c = rewrite plusAssoc k b c in ?plusAssoc_rhs_2 <br>
			</code>
			<br>We can now check the type of the hole after the expression was rewritten:</br>
			<code class="code-block">
				|k : Nat<br>
				|b : Nat<br>
				|c : Nat<br>
				|_rewrite_rule : plus k (plus b c) = plus (plus k b) c<br>
				|--------------------------------------<br>
				|plusAssoc_rhs_2 : S (plus (plus k b) c) = S (plus (plus k b) c)<br>
			</code>
			<br>You can see the rewrite rule that the program uses to find different ways to write the predicate, and you can see both sides are equivalent.<br> Again, Idris can prove this trivially using the proof-search tool (CTRL-ALT-S on atom)</br>
			<code class="code-block">
				|plusAssoc : (a, b, c : Nat) -> a `plus` (b `plus` c) = (a `plus` b) `plus` c<br>
				|plusAssoc Z b c = Refl<br>
				|plusAssoc (S k) b c = rewrite plusAssoc k b c in Refl <br>
			</code>
			<br>And thus, the associativity of addition is proven.</li>
		<li> Proofs provide us with a way to prove that something works for all test cases. </li>
<li>For example, if you wanted to make sure that plus has the associative property in another language,
<br>you would probably write a few test cases with variable amounts of length and complexity. 
<br>Every time you would change the function, you would have to rerun the tests. </li>
<li>With Idris, however, the proof is written in the code! You can be certain that this property exists with whatever numbers you give it,
		and the proof runs every time the code is compiled. </li>

	<li>This is a very elementary proof, however, for something that can be seen relatively easily. Proofs in Idris are for much more complex
ideas, however. <br> You can test functions and even types to make sure that they return a value for every input. </li>
	<li>You can test that the reverse of a list is the reverse of a list. Etc.</li>
					
	</ul>
	<div class="subheader">Useful link</div>
	<ul>
		<li> The official Idris tutorial and documentation: http://docs.idris-lang.org/en/latest/tutorial/</li>
	</ul>
	
	<div class="subheader">Reference</div>
	<ul>
		<li> Dees, I. & Tate, B. (2005). Idris. <i>Seven more languages in seven weeks: Languages that are shaping the future</i> (pp. 243-275).
		Pragmatic Bookshelf.  </li>
	</ul>
</article>

<script src="pl.js"></script>
</body>

<hr noshade size=“2” width=“75%”>

<font size=“1” face=“Verdana, Helvetica, sans-serif, Times”>
&copy; Jonathon P. Henry, Fall 2019, University of Dayton.
Permission to use ideas about
the organization of topics and any notes or material is granted,
provided suitable acknowledgments and citations are made.
</font>
</html>


