[
	{
		"final":    "amatob1",
		"abstract": "<a name=\"amatob1\"/>\r\n<center>\r\n<h3>Concurrent Implementation of the Fast Fourier Tranform in Koltin</h3>\r\n\r\n<h3>Ben W. Amato</h3>\r\n\r\n<b>Abstract</b>\r\n</center>\r\n<blockquote>\r\nWe present an implementation of the Cooley-Tukey Fast Fourier Transform algorithm in the Kotlin programming language. \r\nThe Cooley-Tukey algorithm structure, which partitions the input into two parts and recursively solves each partition,\r\nlends itself to parallelism. Kotlin's coroutines allow for the introduction of concurrency with minimal additional code \r\nthrough it's async and await operators. The utility of the FFT is shown by comparing the Discrete Fourier Transform, \r\nFast Fourier Transform, and Concurrent Fast Fourier Transform when finding the power spectra of an audio file.\r\n</blockquote>\r\n\r\n<br/>\r\nFinal <a href=\"./paper/amatob1-paper.pdf\">paper</a> and <a href=\"./presentation/amatob1-presentation.pdf\">presentation</a>.\r\n",
		"paper":    {
			"modal": false,
			"path":  "finals/amatob1-Final/paper/amatob1-paper.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/amatob1-Final/presentation/amatob1-presentation.pdf"
		}
	},
	{
		"final":    "berkshiret1",
		"abstract": "<a name=\"betkshiret1\"/>\r\n<center>\r\n<h3>A Super Smash Brothers Tournament Locator in F#</h3>\r\n\r\n<h3>Tyler P. Berkshire</h3>\r\n\r\n<b>Abstract</b>\r\n</center>\r\n\r\n<blockquote>\r\nA worldwide tournament locator for one of Nintendo's popular video game series, Super\r\nSmash Brothers, is implemented in the F# programming language. The system is deployed as a web\r\napplication and utilizes the Fable F# compiler to convert the ecosystem into React and\r\nJavaScript elements. Our application is structured with the Elmish architecture's \"model\r\nview update\" style in mind and uses Webpack to bundle its modules. The tournament data is\r\nretrieved from smash.gg's GraphQL API with API queries implemented in Python.\r\n</blockquote>\r\n\r\n<br/>\r\nFinal <a href=\"./paper/berkshiret1-paper.pdf\">paper</a> and <a href=\"./presentation/berkshiret1-presentation.pdf\">presentation</a>.\r\n",
		"paper":    {
			"modal": false,
			"path":  "finals/berkshiret1-Final/paper/berkshiret1-paper.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/berkshiret1-Final/presentation/berkshiret1-presentation.pdf"
		}
	},
	{
		"final":    "mckernant1",
		"abstract": "<a name=\"mckernant1\"/>\n<center>\n  <h3>Linux/UNIX Hash Verifier Command line Utility in Kotlin</h3>\n\n  <h3>Thomas A. McKernan</h3>\n\n  <b>Abstract</b>\n</center>\n<blockquote>\n  This is a hash verifier in linux/unix.\n  The purpose of this utility is to be able to tell whether a file has been changed since the hash was created.\n  This command line tool is written in Kotlin with Gradle as a dependency manager.\n  Gradle allows us to integrate with tons of existing plugins.\n  The plugin used for this CLI is picocli, which is an annotation based CLI framework.\n</blockquote>\n\n<br/>\nFinal <a href=\"./paper/mckernant1-paper.pdf\">paper</a> and <a href=\"./presentation/mckernant1-presentation.pdf\">presentation</a>.\n",
		"paper":    {
			"modal": false,
			"path":  "finals/mckernant1-Hasher/paper/mckernant1-paper.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/mckernant1-Hasher/presentation/mckernant1-presentation.pdf"
		}
	},
	{
		"final":    "patnaika2",
		"abstract": "<a name=\"patnaika2\"/>\n<center>\n<h3>An Implementation of the Minimax Algorithm with Connect Four in Kotlin</h3>\n\n<h3>Ajay J. Patnaik</h3>\n\n<b>Abstract</b>\n</center>\n<blockquote>\nThis paper presents a system that uses artificial intelligence to play a game of Connect Four. With more than four and a half trillion possible board combinations, the amount of system memory needed would be intractable. Using a depth constraint, we can reduce the amount of computations and memory needed. The artificial intelligence algorithm selected for this system was the minimax algorithm, using an alpha-beta heuristic. The algorithm looks through all of the possible board states, up to the constraint, and returns the next best move. With this implementation of the minimax algorithm, you can play a game of Connect Four against the artificial intelligence with varying levels of difficulty.\n</blockquote>\n\n<br/>\nFinal <a href=\"./paper/patnaika2-Final.pdf\">paper</a> and <a href=\"../presentation/patnaika2-Final.pdf\">presentation</a>.\n",
		"paper":    {
			"modal": false,
			"path":  "finals/patnaika2-Final/paper/patnaika2-Final.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/patnaika2-Final/presentation/patnaika2-Final.pdf"
		}
	},
	{
		"final":    "reichelc1",
		"abstract": "<a name=\"ltalatinian1\"/>\n<center>\n<h3>N-Queens Puzzle in Kotlin</h3>\n\n<h3>Corey J. Reichel</h3>\n\n<b>Abstract</b>\n</center>\n<blockquote>\nPuzzles such as eight spaces or queens games are useful for testing \nthe efficiency of a given algorithm in which there is an exhuastible \ndomain. These puzzles are good models to develop algorithms that have \napplications to various domains in computer science~\\cite{ayub}. With \nthese types of puzzles minimizing search space dramatically improves \nperformance and memory usage as the size of the problem increases. We \ndemonstrate valid solutions to Queen's game on varying size boards with \ndifferent types of algorithms using lazy evaluation and depth first \nsearch algorithms in Kotlin. Starting from simple brute-force algorithms \nthat merely guess and check, to more refined algorithms such as depth-first \nand look-ahead that attempt to trim the search space by eliminate unnecessary computations.\n</blockquote>\n\n<br/>\nFinal <a href=\"../paper/ltalatinian1-paper.pdf\">paper</a> and <a href=\"presentation/reichelc1-presentation.pdf\">presentation</a>.\n",
		"paper":    {
			"modal": false,
			"path":  "finals/reichelc1-Final/reichelc1-Final/paper/paper.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/reichelc1-Final/reichelc1-Final/presentation/reichelc1-presentation.pdf"
		}
	},
	{
		"final":    "schwartzj1",
		"abstract": "<a name=\"schwartzj1\"/>\n<center>\n<h3>Kotlin Mobile Application for PC Control</h3>\n\n<h3>Jacob T. Schwartz</h3>\n\n<b>Abstract</b>\n</center>\n<blockquote>\nWe present a PC remote Bluetooth control application implemented in the Kotlin programming language for Android. Using the Android Bluetooth library, the mobile application communicates with a local server running on a client PC to interact with it’s operating system and perform actions such as volume control, custom keystrokes, turning off or rebooting the device, and more. The client server runs on Kotlin, utilizing the languages ability to interoperate with the Java programming language to utilize Javax’s Bluecove library to communicate with the client machine’s Bluetooth adapter. This is the only option to write a Bluetooth server on any desktop operating system, as the only native Kotlin library for Bluetooth communication, at this time, works exclusively on the Android operating system; Android, nor its fork to create Internet of Things devices (Android of Things) are capable of running alongside major operating systems.\n</blockquote>\n\n<br/>\nFinal <a href=\"../paper/schwartzj1-Lynkr.pdf\">paper</a> and <a href=\"../presentation/Lynkr.pdf\">presentation</a>.\n",
		"paper":    {
			"modal": false,
			"path":  "finals/schwartzj1-Final/paper/schwartzj-Lynkr.pdf"
		},
		"slides":   {
			"modal": false,
			"path":  "finals/schwartzj1-Final/presentation/Lynkr.pdf"
		}
	}
]